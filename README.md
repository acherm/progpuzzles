Supporting material for "Towards programming puzzle spaces"

Jupyter notebooks (Python scripts and explanations), see [ChessPuzzle.ipynb](ChessPuzzle.ipynb) for starting!

Talk given at DiverSE coffee

Abstract:
> I want to tell a story about computational thinking, (artificial) intelligence, and the joy of programming.
> Everything started with a chess puzzle shared by a friend on social media and instead of silently ignoring, I launched a Jupyter notebook.
> I will explain this notebook. I will first explain how I naÃ¯vely iterated until finding a program that fits in a Tweet thanks to opportunistic reuse and some Python hacks.
> I will show how I made vary the 280 characters and build a kind of DSL to resolve other chess puzzles that pop out.
> Then I realized: instead of finding a solution to a puzzle, why not generating puzzles?
> The rough idea is simple: once you know how to resolve a puzzle, you can try to synthesize puzzles that have solution(s).
> The difficult challenge is to synthesize puzzles that are "hard" and "interesting" enough.
> I will briefly illustrate some attempts to explore the "chess puzzle space" with grand-masters' opinions in the loop.
> Finally, I will discuss the applicability of these ideas to any kind of puzzles (with some examples beyond chess).
> Stated differently, I'm defending a new life style: whenever you see a puzzle, launch your notebook, generalize, generate, and move to another puzzle space ;=)
